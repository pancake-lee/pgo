// Code generated by tools/genCURD. DO NOT EDIT.

package data

import (
	"context"

	"github.com/pancake-lee/pgo/internal/pkg/db"
	"github.com/pancake-lee/pgo/internal/pkg/db/model"
	"github.com/pancake-lee/pgo/internal/pkg/perr"
	"github.com/pancake-lee/pgo/pkg/plogger"
)

type UserProjectAssocDO = model.UserProjectAssoc

type userProjectAssocDAO struct{}

var UserProjectAssocDAO userProjectAssocDAO

func (*userProjectAssocDAO) Add(ctx context.Context, userProjectAssoc *UserProjectAssocDO) error {
	if userProjectAssoc == nil {
		return plogger.LogErr(perr.ErrParamInvalid)
	}
	q := db.GetPG().UserProjectAssoc
	err := q.WithContext(ctx).Create(userProjectAssoc)
	if err != nil {
		return plogger.LogErr(err)
	}
	return nil
}

func (*userProjectAssocDAO) GetAll(ctx context.Context,
) (userProjectAssocList []*UserProjectAssocDO, err error) {
	q := db.GetPG().UserProjectAssoc
	userProjectAssocList, err = q.WithContext(ctx).Find()
	if err != nil {
		return nil, plogger.LogErr(err)
	}
	return userProjectAssocList, nil
}


func (*userProjectAssocDAO) GetByUserProj(ctx context.Context, userIDList []int32, projIDList []int32) ([]*UserProjectAssocDO, error) {
	if len(userIDList) == 0 && len(projIDList) == 0 {
		return nil, plogger.LogErr(perr.ErrParamInvalid)
	}
	q := db.GetPG().UserProjectAssoc
	do := q.WithContext(ctx)
	if len(userIDList) > 0 {
		do = do.Where(q.UserID.In(userIDList...))
	}
	if len(projIDList) > 0 {
		do = do.Where(q.ProjID.In(projIDList...))
	}
	list, err := do.Find()
	if err != nil {
		return nil, plogger.LogErr(err)
	}
	return list, nil
}

func (*userProjectAssocDAO) UpdateByID(ctx context.Context, do *UserProjectAssocDO) error {
	if do.ID == 0 {
		return plogger.LogErr(perr.ErrParamInvalid)
	}
	q := db.GetPG().UserProjectAssoc
	_, err := q.WithContext(ctx).Where(q.ID.Eq(do.ID)).Updates(do)
	if err != nil {
		return plogger.LogErr(err)
	}
	return nil
}

func (*userProjectAssocDAO) DelByID(ctx context.Context, iD int32) error {
	if iD == 0 {
		return plogger.LogErr(perr.ErrParamInvalid)
	}
	q := db.GetPG().UserProjectAssoc
	_, err := q.WithContext(ctx).Where(q.ID.Eq(iD)).Delete()
	if err != nil {
		return plogger.LogErr(err)
	}
	return nil
}

func (*userProjectAssocDAO) DelByIDList(ctx context.Context, iDList []int32) error {
	if len(iDList) == 0 {
		return nil
	}
	q := db.GetPG().UserProjectAssoc
	_, err := q.WithContext(ctx).
		Where(q.ID.In(iDList...)).Delete()
	if err != nil {
		return plogger.LogErr(err)
	}
	return nil
}

func (*userProjectAssocDAO) GetByID(ctx context.Context, iD int32,
) (userProjectAssoc *UserProjectAssocDO, err error) {
	if iD == 0 {
		return userProjectAssoc, plogger.LogErr(perr.ErrParamInvalid)
	}

	q := db.GetPG().UserProjectAssoc
	userProjectAssoc, err = q.WithContext(ctx).
		Where(q.ID.Eq(iD)).First()
	if err != nil {
		return nil, plogger.LogErr(err)
	}
	return userProjectAssoc, nil
}

func (*userProjectAssocDAO) GetByIDList(ctx context.Context, iDList []int32,
) (userProjectAssocMap map[int32]*UserProjectAssocDO, err error) {
	if len(iDList) == 0 {
		return nil, nil
	}

	q := db.GetPG().UserProjectAssoc
	l, err := q.WithContext(ctx).
		Where(q.ID.In(iDList...)).Find()
	if err != nil {
		return nil, plogger.LogErr(err)
	}
	userProjectAssocMap = make(map[int32]*UserProjectAssocDO)
	for _, i := range l {
		userProjectAssocMap[i.ID] = i
	}
	return userProjectAssocMap, nil
}

