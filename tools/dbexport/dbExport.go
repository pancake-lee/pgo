package dbexport

import (
	"fmt"
	"inserver/pkg/util"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/pancake-lee/pgo/pkg/pdb"
	"github.com/pancake-lee/pgo/pkg/plogger"
)

func DumpTable(tbl *Table, outputFolder string, filter string) error {
	// 确保输出文件夹存在
	if err := os.MkdirAll(outputFolder, 0755); err != nil {
		plogger.Errorf("Failed to create output folder %s: %v", outputFolder, err)
		return err
	}

	// 构建输出文件路径
	outputFile := filepath.Join(outputFolder, tbl.TableName+".sql")

	// 如果filter包含子查询，使用代码直接查询
	if strings.Contains(strings.ToUpper(filter), "SELECT") {
		return dumpTableByQuery(tbl, outputFile, filter)
	}

	// 否则使用mysqldump
	return dumpTableByMysqldump(tbl, outputFile, filter)
}

// dumpTableByQuery 通过直接查询数据库生成INSERT语句
func dumpTableByQuery(tbl *Table, outputFile string, filter string) error {
	// 构建查询语句
	query := fmt.Sprintf("SELECT * FROM %s", tbl.TableName)
	if filter != "" {
		query += " WHERE " + filter
	}

	// 执行查询
	db, err := pdb.GetDB()
	if err != nil {
		plogger.Errorf("Failed to get database connection: %v", err)
		return err
	}
	rows, err := db.Query(query)
	if err != nil {
		plogger.Errorf("Failed to query table %s: %v", tbl.TableName, err)
		return err
	}
	defer rows.Close()

	// 创建输出文件
	outFile, err := os.Create(outputFile)
	if err != nil {
		plogger.Errorf("Failed to create output file %s: %v", outputFile, err)
		return err
	}
	defer outFile.Close()

	// 获取列信息
	columns, err := rows.Columns()
	if err != nil {
		plogger.Errorf("Failed to get columns for table %s: %v", tbl.TableName, err)
		return err
	}

	// 写入文件头部注释
	fmt.Fprintf(outFile, "-- Table: %s\n", tbl.TableName)
	fmt.Fprintf(outFile, "-- Generated by dbexport tool\n\n")

	// 准备扫描数据的容器
	values := make([]interface{}, len(columns))
	valuePtrs := make([]interface{}, len(columns))
	for i := range values {
		valuePtrs[i] = &values[i]
	}

	// 逐行处理数据
	for rows.Next() {
		if err := rows.Scan(valuePtrs...); err != nil {
			plogger.Errorf("Failed to scan row: %v", err)
			continue
		}

		// 构建INSERT语句
		insertSQL := buildInsertSQL(tbl.TableName, columns, values)
		fmt.Fprintln(outFile, insertSQL)
	}

	if err := rows.Err(); err != nil {
		plogger.Errorf("Error during row iteration: %v", err)
		return err
	}

	plogger.Debugf("Successfully dumped table %s to %s by query", tbl.TableName, outputFile)
	return nil
}

// buildInsertSQL 构建INSERT语句
func buildInsertSQL(tableName string, columns []string, values []interface{}) string {
	var valueStrs []string

	for _, value := range values {
		if value == nil {
			valueStrs = append(valueStrs, "NULL")
		} else {
			switch v := value.(type) {
			case string:
				// 转义单引号
				escaped := strings.ReplaceAll(v, "'", "''")
				valueStrs = append(valueStrs, fmt.Sprintf("'%s'", escaped))
			case []byte:
				// 处理二进制数据
				escaped := strings.ReplaceAll(string(v), "'", "''")
				valueStrs = append(valueStrs, fmt.Sprintf("'%s'", escaped))
			case time.Time:
				valueStrs = append(valueStrs, fmt.Sprintf("'%s'", v.Format("2006-01-02 15:04:05")))
			default:
				valueStrs = append(valueStrs, fmt.Sprintf("%v", v))
			}
		}
	}

	return fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s);",
		tableName,
		strings.Join(columns, ", "),
		strings.Join(valueStrs, ", "))
}

// dumpTableByMysqldump 使用mysqldump导出数据
func dumpTableByMysqldump(tbl *Table, outputFile string, filter string) error {
	// 构建mysqldump命令
	// 假设使用相同的数据库连接配置

	sqlArgs := []string{
		"-h", pdb.Host,
		"-P", util.Int32ToStr(pdb.Port),
		"-u", pdb.User,
		"-p" + pdb.Password,
		"--single-transaction",
		"--routines",
		"--triggers",
		"--complete-insert",
		pdb.DbName,
		tbl.TableName,
	}
	if filter != "" {
		sqlArgs = append(sqlArgs, "--where="+filter)
	}

	cmd := exec.Command("mysqldump", sqlArgs...)

	// 创建输出文件
	outFile, err := os.Create(outputFile)
	if err != nil {
		plogger.Errorf("Failed to create output file %s: %v", outputFile, err)
		return err
	}
	defer outFile.Close()

	// 设置命令输出到文件
	cmd.Stdout = outFile
	cmd.Stderr = os.Stderr

	// 执行命令
	if err := cmd.Run(); err != nil {
		plogger.Errorf("Failed to dump table %s: %v", tbl.TableName, err)
		return err
	}

	plogger.Debugf("Successfully dumped table %s to %s", tbl.TableName, outputFile)
	return nil
}
