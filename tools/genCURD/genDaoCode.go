package main

import (
	"fmt"
	"log"
	"os"
	"strings"

	"github.com/pancake-lee/pgo/pkg/plogger"
	"github.com/pancake-lee/pgo/pkg/putil"
)

// 生成 curd 的 dao 代码
const daoTplPath = "internal/abandonCodeService/data/dao_AbandonCode.go"

func genDaoCode(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	daoTplBytes, err := os.ReadFile(daoTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	for _, tbl := range tblToSvrMap {
		plogger.Debugf("gen dao code for tbl[%v]", tbl.Model.TableName())

		daoTplCode := string(daoTplBytes)

		daoCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

		daoCodeStr += daoReplace(daoTplCode, tplTable, tbl)

		daoOutputPath := fmt.Sprintf("./internal/%vService/data/", tbl.ServiceName)
		os.MkdirAll(daoOutputPath, 0755)
		err := os.WriteFile(daoOutputPath+"z_dao_"+tbl.UpperCamelName+".gen.go", []byte(daoCodeStr), 0644)
		if err != nil {
			log.Fatalf("write dao code failed, err: %v", err)
		}
	}
}

func daoReplace(codeStr string, tplTable *Table, tbl *Table) string {

	// 如果没有主键，则删除相关代码块
	if tbl.IdxColName == "" {
		codeStr = markPairTool.ReplaceAll("MARK REMOVE IF NO PRIMARY KEY", codeStr, "")
	} else {
		codeStr = markPairTool.RemoveMarkSelf("MARK REMOVE IF NO PRIMARY KEY", codeStr)
		codeStr = tblIdxReplace(codeStr, tplTable, tbl)
	}

	// 处理唯一索引生成的代码
	codeStr = markPairTool.ReplaceLoop("MARK REPEAT INDEX DAO", codeStr, len(tbl.IdxList),
		func(idx int, content string) string {
			indexInfo := tbl.IdxList[idx]
			idxFields := indexInfo.Fields

			// 构造函数名后缀，例如 ByIdx2Idx3
			funcSuffix := "By" + idxNameToCamelCase(indexInfo.Name)
			// 构造参数列表，例如 idx2List []int32, idx3List []int32
			paramList := ""
			// 构造参数检查，例如 len(idx2List) == 0 && len(idx3List) == 0
			paramCheck := ""
			// 构造查询条件
			queryCond := ""

			for i, f := range idxFields {
				paramList += fmt.Sprintf("%sList []%s", f.IdxParmName, f.IdxColType)
				paramCheck += fmt.Sprintf("len(%sList) == 0", f.IdxParmName)

				queryCond += fmt.Sprintf(`
	if len(%sList) > 0 {
		do = do.Where(q.%s.In(%sList...))
	}`, f.IdxParmName, f.IdxColName, f.IdxParmName)

				if i < len(idxFields)-1 {
					paramList += ", "
					paramCheck += " && "
				}
			}

			newContent := fmt.Sprintf(`
func (*%sDAO) Get%s(ctx context.Context, %s) ([]*%sDO, error) {
	if %s {
		return nil, plogger.LogErr(perr.ErrParamInvalid)
	}
	q := db.GetPG().%s
	do := q.WithContext(ctx)%s
	list, err := do.Find()
	if err != nil {
		return nil, plogger.LogErr(err)
	}
	return list, nil
}
`, tbl.LowerCamelName, funcSuffix, paramList, tbl.UpperCamelName, paramCheck, tbl.UpperCamelName, queryCond)

			return newContent
		})

	return tblNameReplace(codeStr, tplTable, tbl)
}

// --------------------------------------------------
func tblIdxReplace(codeStr string, tplTable *Table, tbl *Table) string {
	// 替换主键的字段名，参数名，参数类型
	codeStr = strings.ReplaceAll(codeStr,
		tplTable.IdxColName, putil.StrIdToLower(tbl.IdxColName))

	codeStr = strings.ReplaceAll(codeStr,
		tplTable.IdxColType, tbl.IdxColType)

	codeStr = strings.ReplaceAll(codeStr,
		tplTable.IdxParmName, tbl.IdxParmName)

	return codeStr
}

func tblNameReplace(codeStr string, tplTable *Table, tbl *Table) string {
	// 把表名的4种命名方式都替换一遍
	codeStr = strings.ReplaceAll(codeStr,
		tplTable.Model.TableName(), tbl.Model.TableName())

	codeStr = strings.ReplaceAll(codeStr,
		tplTable.HyphenName, tbl.HyphenName)

	codeStr = strings.ReplaceAll(codeStr,
		tplTable.LowerCamelName, tbl.LowerCamelName)

	codeStr = strings.ReplaceAll(codeStr,
		tplTable.UpperCamelName, tbl.UpperCamelName)

	return codeStr
}
