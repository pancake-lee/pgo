package main

import (
	"fmt"
	"gogogo/pkg/db/dao/model"
	"gogogo/pkg/util"
	"log"
	"os"
	"os/exec"
	"reflect"
	"sort"
	"strings"
)

type dbModel interface {
	TableName() string
}

type Table struct {
	ServiceName string
	Model       dbModel

	//生成代码需要的值
	HyphenName     string // 中横线[-]命名
	LowerCamelName string // 驼峰命名，首字母小写
	UpperCamelName string // 驼峰命名，首字母大写

	IdxColName  string // 索引列名，model字段名
	IdxColType  string // 索引列类型，model字段类型
	IdxParmName string // 索引列名，读写值的参数名

	FieldList []*reflect.StructField
}

func (t *Table) String() string {
	return "ServiceName[" + t.ServiceName + "]" +
		" Model[" + t.Model.TableName() + "]" +
		" HyphenName[" + t.HyphenName + "]" +
		" LowerCamelName[" + t.LowerCamelName + "]" +
		" UpperCamelName[" + t.UpperCamelName + "]" +
		" IdxColName[" + t.IdxColName + "]" +
		" IdxColType[" + t.IdxColType + "]" +
		" IdxParmName[" + t.IdxParmName + "]"
}

var tblToSvrMap = make(map[string]*Table)

func addTable(m dbModel, svrName string) {
	tblToSvrMap[m.TableName()] = newTable(m, svrName)
}
func newTable(m dbModel, svrName string) *Table {
	tbl := Table{
		ServiceName: svrName,
		Model:       m,
	}
	tblName := tbl.Model.TableName()
	tbl.HyphenName = strings.ReplaceAll(tblName, "_", "-")
	tbl.UpperCamelName = util.StrToCamelCase(tblName)
	tbl.LowerCamelName = util.StrFirstToLower(tbl.UpperCamelName)
	return &tbl
}

func main() {

	addTable(&model.User{}, "userService")
	addTable(&model.UserDept{}, "userService")
	addTable(&model.UserDeptAssoc{}, "userService")
	addTable(&model.UserJob{}, "userService")

	//读取数据库表结构
	for _, tbl := range tblToSvrMap {
		log.Printf("table: %v", tbl.Model.TableName())

		val := reflect.ValueOf(tbl.Model).Elem()
		for i := 0; i < val.NumField(); i++ {
			field := val.Type().Field(i)
			tbl.FieldList = append(tbl.FieldList, &field)

			// log.Printf("Field[%s] Type[%s] Tag[%v]", field.Name, field.Type, field.Tag)
			if tbl.IdxColName == "" &&
				strings.Contains(field.Tag.Get("gorm"), "primaryKey") {
				tbl.IdxColName = field.Name
				tbl.IdxColType = field.Type.String()
				tbl.IdxParmName = util.StrFirstToLower(util.StrIdToLower(tbl.IdxColName))
			}
		}
		log.Println("tbl info : ", tbl)
	}

	tplTable := newTable(&model.AbandonCode{}, "abandonService")
	tplTable.IdxColName = "Idx1"
	tplTable.IdxColType = "int32"
	tplTable.IdxParmName = "idx1"

	genDaoCode(tblToSvrMap, tplTable)
	genProto(tblToSvrMap, tplTable)

	// 调用 protoc 生成 go 代码
	cmd := exec.Command("make", "api")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("make proto failed, err: %v, out: \n%v", err, string(out))
	}

	genServiceCode(tblToSvrMap, tplTable)
}

// 生成 curd 的 dao 代码
const daoTplPath = "internal/abandonService/data/dao_AbandonCode.go"
const daoIdxTplPath = "internal/abandonService/data/dao_AbandonCodeIdx.go"

func genDaoCode(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	daoTplBytes, err := os.ReadFile(daoTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	daoIdxTplBytes, err := os.ReadFile(daoIdxTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	for _, tbl := range tblToSvrMap {

		daoTplCode := string(daoTplBytes)
		if tbl.IdxColName != "" {
			daoTplCode += handleMark1(string(daoIdxTplBytes))
		}

		daoCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

		daoCodeStr += codeReplace(daoTplCode, tplTable, tbl)

		daoOutputPath := fmt.Sprintf("./internal/%v/data/", tbl.ServiceName)
		os.MkdirAll(daoOutputPath, 0755)
		err := os.WriteFile(daoOutputPath+"dao_"+tbl.UpperCamelName+".gen.go", []byte(daoCodeStr), 0644)
		if err != nil {
			log.Fatalf("write dao code failed, err: %v", err)
		}
	}
}

// 生成 curd 的 proto 定义，包括数据结构和接口定义
const pbTplPath = "pkg/proto/AbandonCode.proto"

func genProto(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	//以service为单位生成proto文件
	svrNameToTblMap := make(map[string][]*Table)
	for _, tbl := range tblToSvrMap {
		svrNameToTblMap[tbl.ServiceName] = append(svrNameToTblMap[tbl.ServiceName], tbl)
	}

	pbTplBytes, err := os.ReadFile(pbTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	pbTplHeader, pbTplForOneTbl := handleMark2(string(pbTplBytes))

	for svrName, tblList := range svrNameToTblMap {

		pbCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

		pbCodeStr += pbTplHeader

		sort.Slice(tblList, func(i, j int) bool {
			return tblList[i].Model.TableName() < tblList[j].Model.TableName()
		})
		for _, tbl := range tblList {
			pbCodeForOneTbl := codeReplace(pbTplForOneTbl, tplTable, tbl)

			pbColList := ""
			for i, field := range tbl.FieldList {
				pbColList += fmt.Sprintf(
					"    %v %v = %v;\n",
					field.Type.String(),
					util.StrFirstToLower(util.StrIdToLower(field.Name)),
					i+1)
			}

			pbCodeForOneTbl = replaceMarkAll("MARK 3",
				pbCodeForOneTbl, pbColList)

			//TODO 扩展多个索引的情况
			pbKeyColList := ""
			if tbl.IdxColName != "" {
				pbKeyColList = fmt.Sprintf(
					"    repeated %v %vList = 1;\n",
					tbl.IdxColType,
					util.StrFirstToLower(util.StrIdToLower(tbl.IdxColName)))
			}
			pbCodeForOneTbl = replaceMarkAll("MARK 4",
				pbCodeForOneTbl, pbKeyColList)

			if tbl.IdxColName == "" {
				pbCodeForOneTbl = replaceMarkAll("MARK 5",
					pbCodeForOneTbl, "")
			}

			pbCodeStr += pbCodeForOneTbl
		}

		pbOutputPath := "./pkg/proto/"
		os.MkdirAll(pbOutputPath, 0755)
		err = os.WriteFile(pbOutputPath+svrName+".gen.proto", []byte(pbCodeStr), 0644)
		if err != nil {
			log.Fatalf("write dao code failed, err: %v", err)
		}
	}
}

// 生成 curd 的 service 代码，包括 DO 和 DTO 的转换代码，基础 curd 的实现
const daoSvrPath = "internal/abandonService/service/svc_AbandonCode.go"

func genServiceCode(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	//以service为单位生成proto文件
	svrNameToTblMap := make(map[string][]*Table)
	for _, tbl := range tblToSvrMap {
		svrNameToTblMap[tbl.ServiceName] = append(svrNameToTblMap[tbl.ServiceName], tbl)
	}

	ctlTplBytes, err := os.ReadFile(daoSvrPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	for svrName, tblList := range svrNameToTblMap {
		ctlOutputPath := fmt.Sprintf("./internal/%v/service/", svrName)
		os.MkdirAll(ctlOutputPath, 0755)

		for _, tbl := range tblList {
			svcCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

			ctlTplCode := string(ctlTplBytes)

			svcCodeStr += codeReplace(ctlTplCode, tplTable, tbl)

			if tbl.IdxColName == "" {
				svcCodeStr = replaceMarkAll("MARK 5", svcCodeStr, "")
			}

			do2dtoCode := ""
			for _, field := range tbl.FieldList {
				do2dtoCode += fmt.Sprintf(
					"        %v: do.%v,\n",
					util.StrToCamelCase(util.StrIdToLower(field.Name)),
					util.StrToCamelCase(field.Name))
			}
			svcCodeStr = replaceMarkAll("MARK 6", svcCodeStr, do2dtoCode)

			dto2doCode := ""
			for _, field := range tbl.FieldList {
				dto2doCode += fmt.Sprintf(
					"        %v: dto.%v,\n",
					util.StrToCamelCase(field.Name),
					util.StrToCamelCase(util.StrIdToLower(field.Name)))
			}
			svcCodeStr = replaceMarkAll("MARK 7", svcCodeStr, dto2doCode)

			err := os.WriteFile(ctlOutputPath+"svc_"+tbl.LowerCamelName+".gen.go", []byte(svcCodeStr), 0644)
			if err != nil {
				log.Fatalf("write dao code failed, err: %v", err)
			}
		}
	}
}

func getLastLineEndOfMark(fileStr, mark string) int {
	i := strings.Index(fileStr, mark)
	return strings.LastIndex(fileStr[:i], "\n") + 1
}

func getNextLineStartOfMark(fileStr, mark string) int {
	i := strings.Index(fileStr, mark)
	return i + strings.Index(fileStr[i:], "\n") + 1
}

// 删掉Mark1之前的文件内容
func handleMark1(fileStr string) string {
	return fileStr[getNextLineStartOfMark(fileStr, "MARK 1"):]
}

// 分离Mark2前后的内容
func handleMark2(fileStr string) (string, string) {
	iLast := getLastLineEndOfMark(fileStr, "MARK 2")
	iNext := getNextLineStartOfMark(fileStr, "MARK 2")
	return fileStr[:iLast], fileStr[iNext:]
}

// 替换Mark3包裹的内容
func replaceMarkAll(mark, fileStr, replaceStr string) string {
	for strings.Contains(fileStr, mark) {
		fileStr = replaceMarkOnce(mark, fileStr, replaceStr)
	}
	return fileStr
}
func replaceMarkOnce(mark, fileStr, replaceStr string) string {
	iStart := getLastLineEndOfMark(fileStr, mark+" START")
	iEnd := getNextLineStartOfMark(fileStr, mark+" END")
	return fileStr[:iStart] + replaceStr + fileStr[iEnd:]
}

func codeReplace(
	tplCode string, tplTable *Table, tbl *Table,
) string {

	codeStr := tplCode

	codeStr = strings.ReplaceAll(codeStr, tplTable.Model.TableName(), tbl.Model.TableName())
	codeStr = strings.ReplaceAll(codeStr, tplTable.ServiceName, tbl.ServiceName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.HyphenName, tbl.HyphenName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.LowerCamelName, tbl.LowerCamelName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.UpperCamelName, tbl.UpperCamelName)

	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxColName, util.StrIdToLower(tbl.IdxColName))
	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxColType, tbl.IdxColType)
	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxParmName, tbl.IdxParmName)
	return codeStr
}
