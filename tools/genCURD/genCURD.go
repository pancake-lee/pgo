package main

import (
	"fmt"
	"gogogo/pkg/db/dao/model"
	"gogogo/pkg/util"
	"log"
	"os"
	"os/exec"
	"reflect"
	"sort"
	"strings"
)

type dbModel interface {
	TableName() string
}

type Table struct {
	ServiceName string
	Model       dbModel

	//生成代码需要的值
	HyphenName     string // 中横线[-]命名
	LowerCamelName string // 驼峰命名，首字母小写
	UpperCamelName string // 驼峰命名，首字母大写

	IdxColName  string // 索引列名，model字段名
	IdxColType  string // 索引列类型，model字段类型
	IdxParmName string // 索引列名，读写值的参数名

	FieldList []*reflect.StructField
}

func (t *Table) String() string {
	return "ServiceName[" + t.ServiceName + "]" +
		" Model[" + t.Model.TableName() + "]" +
		" HyphenName[" + t.HyphenName + "]" +
		" LowerCamelName[" + t.LowerCamelName + "]" +
		" UpperCamelName[" + t.UpperCamelName + "]" +
		" IdxColName[" + t.IdxColName + "]" +
		" IdxColType[" + t.IdxColType + "]" +
		" IdxParmName[" + t.IdxParmName + "]"
}

var tblToSvrMap = make(map[string]*Table)

func addTable(m dbModel, svcName string) {
	tblToSvrMap[m.TableName()] = newTable(m, svcName)
}
func newTable(m dbModel, svcName string) *Table {
	tbl := Table{
		ServiceName: svcName,
		Model:       m,
	}
	tblName := tbl.Model.TableName()
	tbl.HyphenName = strings.ReplaceAll(tblName, "_", "-")
	tbl.UpperCamelName = util.StrToCamelCase(tblName)
	tbl.LowerCamelName = util.StrFirstToLower(tbl.UpperCamelName)
	return &tbl
}

func main() {

	addTable(&model.User{}, "user")
	addTable(&model.UserDept{}, "user")
	addTable(&model.UserDeptAssoc{}, "user")
	addTable(&model.UserJob{}, "user")

	//读取数据库表结构
	for _, tbl := range tblToSvrMap {
		log.Printf("table: %v", tbl.Model.TableName())

		val := reflect.ValueOf(tbl.Model).Elem()
		for i := 0; i < val.NumField(); i++ {
			field := val.Type().Field(i)
			tbl.FieldList = append(tbl.FieldList, &field)

			// log.Printf("Field[%s] Type[%s] Tag[%v]", field.Name, field.Type, field.Tag)
			if tbl.IdxColName == "" &&
				strings.Contains(field.Tag.Get("gorm"), "primaryKey") {
				tbl.IdxColName = field.Name
				tbl.IdxColType = field.Type.String()
				tbl.IdxParmName = util.StrFirstToLower(util.StrIdToLower(tbl.IdxColName))
			}
		}
		log.Println("tbl info : ", tbl)
	}

	tplTable := newTable(&model.AbandonCode{}, "abandonCode")
	tplTable.IdxColName = "Idx1"
	tplTable.IdxColType = "int32"
	tplTable.IdxParmName = "idx1"

	genDaoCode(tblToSvrMap, tplTable)
	genProto(tblToSvrMap, tplTable)

	// 调用 protoc 生成 go 代码
	cmd := exec.Command("make", "api")
	out, err := cmd.CombinedOutput()
	if err != nil {
		log.Fatalf("make proto failed, err: %v, out: \n%v", err, string(out))
	}

	genServiceCode(tblToSvrMap, tplTable)
}

// 生成 curd 的 dao 代码
const daoTplPath = "internal/abandonCodeService/data/dao_AbandonCode.go"

func genDaoCode(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	daoTplBytes, err := os.ReadFile(daoTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	for _, tbl := range tblToSvrMap {

		daoTplCode := string(daoTplBytes)

		daoCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

		daoCodeStr += codeReplace(daoTplCode, tplTable, tbl)

		daoOutputPath := fmt.Sprintf("./internal/%v/data/", tbl.ServiceName)
		os.MkdirAll(daoOutputPath, 0755)
		err := os.WriteFile(daoOutputPath+"dao_"+tbl.UpperCamelName+".gen.go", []byte(daoCodeStr), 0644)
		if err != nil {
			log.Fatalf("write dao code failed, err: %v", err)
		}
	}
}

// 生成 curd 的 proto 定义，包括数据结构和接口定义
const pbTplPath = "pkg/proto/AbandonCode.proto"

func genProto(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	//以service为单位生成proto文件
	svcNameToTblMap := make(map[string][]*Table)
	for _, tbl := range tblToSvrMap {
		svcNameToTblMap[tbl.ServiceName] = append(svcNameToTblMap[tbl.ServiceName], tbl)
	}

	pbTplBytes, err := os.ReadFile(pbTplPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	pbTpl := string(pbTplBytes)
	pbTplApiForOneTbl := getMarkContent(pbTpl, "MARK REPEAT API")
	pbTplMsgForOneTbl := getMarkContent(pbTpl, "MARK REPEAT MSG")

	for svcName, tblList := range svcNameToTblMap {

		pbCodeApi := ""
		pbCodeMsg := ""

		sort.Slice(tblList, func(i, j int) bool {
			return tblList[i].Model.TableName() < tblList[j].Model.TableName()
		})
		for _, tbl := range tblList {
			pbApiCodeForOneTbl := codeReplace(pbTplApiForOneTbl, tplTable, tbl)
			pbCodeApi += pbApiCodeForOneTbl

			pbMsgCodeForOneTbl := codeReplace(pbTplMsgForOneTbl, tplTable, tbl)

			pbColList := ""
			for i, field := range tbl.FieldList {
				pbColList += fmt.Sprintf(
					"    %v %v = %v;\n",
					field.Type.String(),
					util.StrFirstToLower(util.StrIdToLower(field.Name)),
					i+1)
			}

			pbMsgCodeForOneTbl = replaceMarkAll("MARK REPLACE PB COL",
				pbMsgCodeForOneTbl, pbColList)

			//TODO 扩展多个索引的情况
			pbKeyColList := ""
			if tbl.IdxColName != "" {
				pbKeyColList = fmt.Sprintf(
					"    repeated %v %vList = 1;\n",
					tbl.IdxColType,
					util.StrFirstToLower(util.StrIdToLower(tbl.IdxColName)))
			}
			pbMsgCodeForOneTbl = replaceMarkAll("MARK REPLACE PB IDX",
				pbMsgCodeForOneTbl, pbKeyColList)

			pbCodeMsg += pbMsgCodeForOneTbl
		}

		pbCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"
		pbCodeStr += pbTpl
		pbCodeStr = strings.ReplaceAll(pbCodeStr,
			tplTable.ServiceName, svcName)
		pbCodeStr = replaceMarkOnce("MARK REPEAT API", pbCodeStr, pbCodeApi)
		pbCodeStr = replaceMarkOnce("MARK REPEAT MSG", pbCodeStr, pbCodeMsg)

		pbOutputPath := "./pkg/proto/"
		os.MkdirAll(pbOutputPath, 0755)
		err = os.WriteFile(pbOutputPath+svcName+"Service.gen.proto", []byte(pbCodeStr), 0644)
		if err != nil {
			log.Fatalf("write dao code failed, err: %v", err)
		}
	}
}

// 生成 curd 的 service 代码，包括 DO 和 DTO 的转换代码，基础 curd 的实现
const daoSvrPath = "internal/abandonCodeService/service/svc_AbandonCode.go"

func genServiceCode(
	tblToSvrMap map[string]*Table,
	tplTable *Table,
) {
	//以service为单位生成proto文件
	svcNameToTblMap := make(map[string][]*Table)
	for _, tbl := range tblToSvrMap {
		svcNameToTblMap[tbl.ServiceName] = append(svcNameToTblMap[tbl.ServiceName], tbl)
	}

	ctlTplBytes, err := os.ReadFile(daoSvrPath)
	if err != nil {
		log.Fatalf("read tpl file failed, err: %v", err)
	}

	for svcName, tblList := range svcNameToTblMap {
		ctlOutputPath := fmt.Sprintf("./internal/%vService/service/", svcName)
		os.MkdirAll(ctlOutputPath, 0755)

		for _, tbl := range tblList {
			svcCodeStr := `// Code generated by tools/genCURD. DO NOT EDIT.` + "\n\n"

			ctlTplCode := string(ctlTplBytes)
			log.Printf("svc[%v] tbl[%v]", svcName, tbl.Model.TableName())
			svcCodeStr += codeReplace(ctlTplCode, tplTable, tbl)

			do2dtoCode := ""
			for _, field := range tbl.FieldList {
				do2dtoCode += fmt.Sprintf(
					"        %v: do.%v,\n",
					util.StrToCamelCase(util.StrIdToLower(field.Name)),
					util.StrToCamelCase(field.Name))
			}
			svcCodeStr = replaceMarkAll("MARK REPLACE DO2DTO", svcCodeStr, do2dtoCode)

			dto2doCode := ""
			for _, field := range tbl.FieldList {
				dto2doCode += fmt.Sprintf(
					"        %v: dto.%v,\n",
					util.StrToCamelCase(field.Name),
					util.StrToCamelCase(util.StrIdToLower(field.Name)))
			}
			svcCodeStr = replaceMarkAll("MARK REPLACE DTO2DO", svcCodeStr, dto2doCode)

			err := os.WriteFile(ctlOutputPath+"svc_"+tbl.LowerCamelName+".gen.go", []byte(svcCodeStr), 0644)
			if err != nil {
				log.Fatalf("write dao code failed, err: %v", err)
			}
		}
	}
}

func getLastLineEndOfMark(fileStr, mark string) int {
	i := strings.Index(fileStr, mark)
	if i == -1 {
		log.Printf("mark not found, mark: %v\n", mark)
		return -1
	}
	return strings.LastIndex(fileStr[:i], "\n") + 1
}

func getNextLineStartOfMark(fileStr, mark string) int {
	i := strings.Index(fileStr, mark)
	if i == -1 {
		log.Printf("mark not found, mark: %v\n", mark)
		return -1
	}
	return i + strings.Index(fileStr[i:], "\n") + 1
}

// 获取标记的内容
func getMarkContent(fileStr string, mark string) string {
	nextOfStart := getNextLineStartOfMark(fileStr, mark+" START")
	lastOfEnd := getLastLineEndOfMark(fileStr, mark+" END")
	if nextOfStart == -1 || lastOfEnd == -1 {
		log.Printf("mark not found, mark: %v\n", mark)
		return ""
	}
	return fileStr[nextOfStart:lastOfEnd]
}

// 替换标记的内容
func replaceMarkAll(mark, fileStr, replaceStr string) string {
	for strings.Contains(fileStr, mark) {
		fileStr = replaceMarkOnce(mark, fileStr, replaceStr)
	}
	return fileStr
}

func replaceMarkOnce(mark, fileStr, replaceStr string) string {
	iStart := getLastLineEndOfMark(fileStr, mark+" START")
	iEnd := getNextLineStartOfMark(fileStr, mark+" END")
	if iStart == -1 || iEnd == -1 {
		log.Printf("mark not found, mark: %v\n", mark)
		return fileStr
	}
	return fileStr[:iStart] + replaceStr + fileStr[iEnd:]
}

// 标记无需操作，删掉标记注释本身
func removeMarkAll(mark, fileStr string) string {
	for strings.Contains(fileStr, mark) {
		fileStr = removeMarkOnce(mark, fileStr)
	}
	return fileStr
}
func removeMarkOnce(mark, fileStr string) string {
	lastOfStart := getLastLineEndOfMark(fileStr, mark+" START")
	nextOfStart := getNextLineStartOfMark(fileStr, mark+" START")
	lastOfEnd := getLastLineEndOfMark(fileStr, mark+" END")
	nextOfEnd := getNextLineStartOfMark(fileStr, mark+" END")
	if lastOfStart == -1 || nextOfStart == -1 || lastOfEnd == -1 || nextOfEnd == -1 {
		log.Printf("mark not found, mark: %v\n", mark)
		return fileStr
	}
	return fileStr[:lastOfStart] + fileStr[nextOfStart:lastOfEnd] + fileStr[nextOfEnd:]
}

func codeReplace(
	tplCode string, tplTable *Table, tbl *Table,
) string {

	codeStr := tplCode

	if tbl.IdxColName == "" {
		codeStr = replaceMarkAll("MARK REPLACE IDX", codeStr, "")
	} else {
		codeStr = removeMarkAll("MARK REPLACE IDX", codeStr)
	}

	codeStr = strings.ReplaceAll(codeStr, tplTable.Model.TableName(), tbl.Model.TableName())
	log.Printf("tplTable.ServiceName[%v] tbl.ServiceName[%v]", tplTable.ServiceName, tbl.ServiceName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.ServiceName, tbl.ServiceName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.HyphenName, tbl.HyphenName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.LowerCamelName, tbl.LowerCamelName)
	codeStr = strings.ReplaceAll(codeStr, tplTable.UpperCamelName, tbl.UpperCamelName)

	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxColName, util.StrIdToLower(tbl.IdxColName))
	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxColType, tbl.IdxColType)
	codeStr = strings.ReplaceAll(codeStr, tplTable.IdxParmName, tbl.IdxParmName)

	return codeStr
}
