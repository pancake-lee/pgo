# 造轮子

刚开始做这个库时，思路大致是：

新增一个表，将首先用gorm-gen生成数据库代码；

自己写个工具，生成一致的protobuf结构体，以及最基本的CURD接口定义；

再通过protoc生成接口代码，最后用kratos提供服务。

# Sponge

然而最近了解到[Sponge](https://github.com/zhufuyi/Sponge/)这个库，基本上就是我想要的东西了。

而现在我自己写的CURD生成的工具还很粗糙，本来还打算慢慢迭代的，支持各个数据库的数据类型，支持复合键的查询接口，吧啦吧啦的。

接下来我们先试用Sponge吧，依然还是同一个功能：

**“组织架构树”：一个用户，可以加入多个部门，在不同部门里分别担任不同的职位**

## 过程记录

### 准备
```shell
echo "export PATH=$PATH:/root/go/bin" > /etc/bashrc
echo "export PATH=$PATH:/root/go/bin" > /etc/profile

go env -w GO111MODULE="on"
go env -w GOPROXY='https://goproxy.cn,direct'

wget https://github.com/protocolbuffers/protobuf/releases/download/v28.1/protoc-28.1-linux-x86_64.zip
unzip protoc-28.1-linux-x86_64.zip
mv bin/protoc /usr/local/bin/
mv include/* /usr/local/include/
rm -rf bin include readme.txt protoc-28.1-linux-x86_64.zip
```

```shell
go install github.com/zhufuyi/Sponge/cmd/Sponge@latest
Sponge init
```
实际使用的Sponge版本是v1.10.3

### 使用Sponge命令来生成代码
```shell
Sponge web http \
--module-name=gogogo \
--server-name=service_user \
--project-name=gogogo \
--db-driver=postgresql \
--db-dsn=gogogo:gogogo@192.168.101.8:5432/gogogo \
--db-table=user,user_job,user_dept,user_dept_assoc \
--suited-mono-repo \
--extended-api
```

- 1：使用Sponge run运行web服务，并生成代码
    - 不采用：每次都要开机要自己运行一下，还占用控制台窗口，懒得搞
    - sponge run --port=7050 --addr=http://127.0.0.1:7050
    - 注意了，addr是不能用0.0.0.0的，他不是listen，而是**web端访问服务端的地址**，想清楚你在哪里访问，你的服务又在哪里，什么样的地址能访问到
- 2：docker运行Sponge，配置见docker/gogogo.yaml
    - 用docker长期运行，先从页面上交互操作
    - 能扒下来本地命令的话就本地运行
    - 比如[SQL-创建web服务-下载]可以从浏览器DevTools可以找到参数如下，则后续直接使用命令即可
        ```json
        {
            "path": "web-http",
            "arg": "web http --module-name=gogogo --server-name=service_user --project-name=gogogo --repo-addr= --db-driver=postgresql --db-dsn=gogogo:gogogo@192.168.101.8:5432/gogogo --db-table=user,user_job,user_dept,user_dept_assoc --embed=false --suited-mono-repo=true --extended-api=true"
        }
        ```
    - 注意结合help来确定命令行参数如何传递，如接口参数```--embed=false```对应命令应该是```不出现--embed``` 
- 3：网页操作，通过pgsql已有的库生成代码，则service_user服务模块
    - gogogo:gogogo@192.168.101.8:5432/gogogo
    - 注意了，ip:port是**Sponge服务端连接数据库的地址**

### 进一步生成user模块的文档
```shell
cd service_user
make docs
```

### 编译运行
```shell
make run
```

### 编写测试
没有实际编写测试代码，直接在swagger上调用接口，确实已经能实现功能了

### 问题记录
- 表结构有一定要求
    - 失败后先手动build
        ```shell
        go build -o cmd/service_user/service_user cmd/service_user/main.go 
        ```
    - 报错1
        - user表对应代码生成了的注释不知道为什么换行了导致编译失败
        - `// The name of /n the user`
        - 原来是因为我user.sql定义了字段的COMMENT，里面就包含了换行，改掉就好了
    - 报错2：
        - 生成的代码里要求model.UserDeptAssoc有id列
        - 则所有表都应该定义id自增列

- 对于dao的test，embed参数无法关闭，生成出来的代码都带有CreatedAt等列，不管命令还是网页都关不掉

- 修改端口8080->7060
    - 服务监听端口：service_user/configs/service_user.yml
    - 自带swagger：service_user/docs/docs.go
    - 生成了swagger.json/yaml，可以用于自己另外部署swagger，记得改host的值
    - 注意：每次make docs都会还原成8080，从swag-docs.sh看起来，暂时不支持修改端口，暂时要手动处理

### 关于git提交
根据上面步骤已经运行起来了基本代码，为了理解不同步骤所生成的代码，分几次提交代码
- 非sponse相关的代码，提交一次
- Sponge init生成的内容，应该是“web服务”相关，提交一次
- 在ui生成代码，提交一次
- make docs后，提交一次



# 总结

一句话总结：不直接采用Sponge作为生成CURL代码的工具

原因：**生成的代码完全是“固定”的（最重要的一点，后续的因素也基于这个点）**

- 使用的是Gin，而我想用的是Kratos（并不是谁更好，单纯是我正在使用）
- 生成的代码里包含“sql字符串”，则类似`xxx.where("id = ?", id)`
    - 个人认为orm之所以是orm，至少它要让我用变量来指代id，而不需要使用字符串版本的id
    - [GormGen](https://gorm.io/gen/)可以很好处理这个事情，上述代码大致会改为
        - `xxx.where(a.ID.Eq(id))`
        - 意味着当我需要修改`id`列名为`user_id`时，我不用担心某个角落有一个字符串`id`遗漏了
- 不管使用Gin还是Kratos或其他，我不希望“业务代码”有他们的影子，如`gin.Context`
    - 同理，我也不想“业务代码(handler或controller)”有Gorm的影子，如`db.Where`
    - 从亲身经验来说，这保证了我更容易替换“组件”
    - 具体来说：假设我的项目现在使用“自研的http框架”来提供服务，我想要更换为Kratos来快速获取常见的微服务组件，我不想改动我的“业务代码”。

以上列举了几个“个人喜好”，而每个人都有自己的喜好，尤其是实际工作中，项目采用的“风格”并不是单纯讨论好与坏这么简单，而是结合历史原因、代码现状、人员组成等等因素而决定。  

**所以，生成的代码是固定的，就注定了我无法把Sponge用于实际生产中。**

但是，Sponge依然有很多可取之处，也许接下来“自研”时会参考着其思路来开发。

PS：（马甲）也许只是当前不行，或者只是我还没有Get到Sponge的好，都有可能。

至于回到“自研”这个路线上，我自己的“代码生成工具”具体的特性，就在后面的文档记录吧。这个文档最终以“我无法把Sponge用于实际生产中”结束。

---

# 补充

241201 sponge更新了，新增了自定义模板的功能，试用一下：

没有深度试用，初步简单试了一下，是利用go template做的，则{{.xxx}}来替换文本。

模板代码
```
// abandon_code.go.tmpl
package spongetpl
func AbandonCode() {
	fmt.Println("{{.TableName}}")
}
```

生成代码
```
// abandon_code.go
func AbandonCode() {
	fmt.Println("abandon_code")
}
```

但我依然觉得如果模板本身是go代码，能编译，这个很重要。

同时，生成代码的操作流程我希望可以重复进行，相当于“幂等”。
